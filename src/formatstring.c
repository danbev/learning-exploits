#include <string.h>
#include <stdio.h>

/*
 * 0x0000000000401146
 */
void something() {
  printf("called something....");
}

int main(int argc, char** argv) {
  printf("Format String exploration\n");

  char c[20] = {1,2,3,4,5,6,7,8,9};
  // On x64 the first arguments are passed in rdi, rsi, rdx, r8, r9
  // So the first 5 entries below will be the contents of those registers that
  // will have been pushed onto the stack by printf.
  printf("aaaaaaaaaaaaaaaaaaaaaaa %016p %016p %016p %016p %016p %016p %016p %016p %016p %016p %016p %016p %016p\n"); 
  //printf("aaaaaaaaaaaaaaaaaaaaaaa %016p %016p %016p %016p %016p %016p %207$016p %207$016p\n"); 
  printf("rip stack element: %11$016p\n"); 
  // 0x0000000000401136 address of something
  //
  // Exit machine instructions in hex
  // c7 c0 3c 00 00 00 48 c7 c7 04 00 00 00 0f 05
  // So we have 15 bytes that we want to be written, but notice those 00 bytes
  // which will cause strcpy to stop copying. We can replace these with instructions
  // that produce 0 but that are not 00 bytes. For example xor %rax, %rax would
  // work which is 48 31 c0
  // c7 c0 3c  48 31 c0  48 31 c0  48 31 c0  48 c7 c7 04 48 31 c0 48 31 c0 48 31 c0 0f 05
  // So then we have 26 bytes to write.
  int x = 20;
  const char input[53] = {
    0xc7, 0xc0, 0x48, 0x31, 0xc1, 0x48, 0x31, 0xc0,
    0x48, 0xc7, 0xc7, 0x04, 0x48, 0x31, 0xc0, 0x48,
    0x31, 0xc0, 0x48, 0x31, 0xc0, 0x0f, 0x05,
    'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',
    'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',
    0xd0, 0xd0, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00};

  // &c = 0x0000 7f ff ff ff d0 d0
  //      0x7f ff ff ff d0 d0:
  /*
  const char input[26] = {'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',
    'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'};  
    //0x00, 0x46, 0x11, 0x40, 0x00, 0x00, 0x00}; 
    // Notice that we want to write  the address of our function, but it
    // contains the null character so strcpy will stop when it hits it.
    // So my original idea of just calling something does not work.
    // So lets start really simple and write an assembly program that calls
    // exit with a value of 4.
  */
  strcpy(c, input);
  printf("all done in main...");
  return 0;
}

// 0x7fffffffd0f8: 0x00007ffff7e031a3


