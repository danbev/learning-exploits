# Format String exploits


```console
$ lldb -- ./formatstring
(lldb) br s -n main
(lldb) r
(lldb) memory read -f x -c 9 -s 8 '$rsp - 64'
0x7fffffffd090: 0x00000000000000c2 0x00007fffffffd0c7
0x7fffffffd0a0: 0x00007fffffffd0c6 0x00007ffff7e86545
0x7fffffffd0b0: 0x0000000000000000 0x000000000040120d
0x7fffffffd0c0: 0x0000000000000000 0x0000000000000000
0x7fffffffd0d0: 0x00007fffffffd1d8
```
So we are looking at the stack from $rsp - 64 and then printing the memory
from that location up to rsp. This is looking forward:
```console
        +-------------------------------------+
rsp --> |0x7fffffffd0d0 (140737488343248)     |
        +-------------------------------------+
        |0x7fffffffd0c0 (140737488343232)     |
        +-------------------------------------+
        |0x7fffffffd0b0 (140737488343216)     |
        +-------------------------------------+
        |0x7fffffffd0a0 (140737488343200)     |
        +-------------------------------------+
        |0x7fffffffd090 (140737488343184)     |
        +-------------------------------------+
```
And if we want is to look back up the stack we can use:
```console
(lldb) memory read -f x -c 17 -s 4 '$rsp'
0x7fffffffd0d0: 0xffffd1d8 0x00007fff 0x00401050 0x00000001
0x7fffffffd0e0: 0xffffd1d0 0x00007fff 0x00000000 0x00000000
0x7fffffffd0f0: 0x004011c0 0x00000000 0xf7e031a3 0x00007fff
0x7fffffffd100: 0x00000000 0x00000000 0xffffd1d8 0x00007fff
0x7fffffffd110: 0x00040000
```
Notice that we now start with the current stack pointer which comes first,
followed by the entries that were placed there by the calling function.

```c
  char c[10] = {1,2,3,4,5,6,7,8,9};
  printf("aaaaaaaaaaaaaaaaaaaaaaa %016x %016x %016x %016x\n"); 
```
So I want to figure out how many `%016x`s I need to add to get to see my
a get printed out.

One way is to look at the assembly in lldb and see how much space is getting
reserved on the stack:
```console
lldb) disassemble 
formatstring`main:
    0x401136 <+0>:   push   rbp
    0x401137 <+1>:   mov    rbp, rsp
    0x40113a <+4>:   sub    rsp, 0x30
```
And rember that the value is in hex so we can get the decimal value by:
```console
(lldb) expr -f d --   0x30
(int) $7 = 48
```
And we can then look at 
```console
0x40114f <+25>:  mov    qword ptr [rbp - 0x8], 0x40202a
```
So this is moving the value stored at 0x40202a:
```console
(lldb) memory read -f s 0x40202a
0x0040202a: "bajja"
```
into first 8 bytes of the stack for this function, so the address is -8 and
the the content will fill that entry and the rest up to rbp.

Then we have have nr that we pass a reference to printf.
```console
0x401157 <+33>:  lea    rdx, [rbp - 0xc]
```
And this will be stored as rbp-12, and it takes 4 bytes.

Next we have our `c` array:
```console
0x4011a3 <+109>: movabs rax, 0x807060504030201
0x4011ad <+119>: mov    qword ptr [rbp - 0x16], rax
0x4011b1 <+123>: mov    word ptr [rbp - 0xe], 0x9
```
Notice that the the first 8 entries in the array are added to rax. Then the
this is moved onto the stack at rbp-22. The last value is then moved into
rbp-14.
We have to remember that this above is using the base frame pointer (rbp) but
what we are interested is the stack which is pointed to by rsp.
```console
(lldb) expr -f x --  $rbp - $rsp
(unsigned long) $14 = 0x0000000000000030
(lldb) expr -f d --  $rbp - $rsp
(unsigned long) $15 = 48
```
And this is pretty much what we saw at the beginning where we subtracted 48 from
rsp. So we have to take that into account when trying to figure out how many
values (`%016x`) we need to enter.

In total we have 22 bytes below rbp with data, and rsp is at position 48 so
we have 26 bytes from 48 to get to 22. But we also want to show our value
so we probably have to add 26+10=36 %16x

Now x is a number that should be printed, so I'm thinking that it would be 4
bytes and we also have to take into account the format string itself which will
be the topmost entry on the stack. 

Just remember that what is printed is the content of memory addresses. The first
entry on the stack will be the format string itself which is a pointer to a
string.


```
  char c[10] = {1,2,3,4,5,6,7,8,9};
  printf("aaaaaaaaaaaaaaaaaaaaaaa %016x %016x %016x %016x %016x\n"); 
```
Notice that the format string will be passed to printf in the edi register:
```console
->  0x4011a3 <+109>: movabs rax, 0x807060504030201
    0x4011ad <+119>: mov    qword ptr [rbp - 0x16], rax
    0x4011b1 <+123>: mov    word ptr [rbp - 0xe], 0x9
    0x4011b7 <+129>: mov    edi, 0x4020a0
    0x4011bc <+134>: mov    eax, 0x0
    0x4011c1 <+139>: call   0x401040                  ; symbol stub for: printf
```

If we disassemble printf we can see the following:
```console
libc.so.6`.annobin_printf.c:
    0x7ffff7e33cb0 <+0>:   endbr64 
    0x7ffff7e33cb4 <+4>:   sub    rsp, 0xd8
    0x7ffff7e33cbb <+11>:  mov    r10, rdi
    0x7ffff7e33cbe <+14>:  mov    qword ptr [rsp + 0x28], rsi
    0x7ffff7e33cc3 <+19>:  mov    qword ptr [rsp + 0x30], rdx
    0x7ffff7e33cc8 <+24>:  mov    qword ptr [rsp + 0x38], rcx
    0x7ffff7e33ccd <+29>:  mov    qword ptr [rsp + 0x40], r8
    0x7ffff7e33cd2 <+34>:  mov    qword ptr [rsp + 0x48], r9
```

Before the call we call we can see the following values in these registers:
```console
(lldb) register read rsi rdx rcx r8 r9
     rsi = 0x00000000004052a0
     rdx = 0x0000000000000000
     rcx = 0x0000000000000000
      r8 = 0x0000000000000000
      r9 = 0x0000000000000030
```
And notice the output:
```console
(lldb) n
aaaaaaaaaaaaaaaaaaaaaaa 00000000004052a0 0000000000000000 0000000000000000 0000000000000000 0000000000000030
```
So we can see that printf will first take those values and add them to the
stack. Normally, when parameter are passed in addition to the format string
there registers would used for those value (I think).

So, if we add one more `%016x` we should see what is currently at the top of
the stack:
```
(lldb) n
aaaaaaaaaaaaaaaaaaaaaaa 00000000004052a0 0000000000000000 0000000000000000 0000000000000000 0000000000000030 00000000ffffd1d8
(lldb) memory read -f x -c 1 -s 8 '$rsp'
0x7fffffffd0c0: 0x00007fffffffd1d8
```
So on x64 we will need to take into account the register values that are placed
onto the stack before we can start reading data from the stack.

When we read values off the stack we are only interested in values that are
located behind the current stack pointer (rsp + #).
These are values that have been placed there by ealier code. Anything infront
of the stack pointer is just garbage (unless values have been placed there
without the interaction of the stackpointer which is possible). Also remember
that if we go back far enough we will eventually come across the value that the
that the `call` instruction pushed onto the stack, which will be used by the ret
instruction to pop into the instruction pointer register (rip). So if we can
find the value, by going backwards (rsp+#) and overwrite that value we could get
the program to jump there. But how do we go about overwriting?



