### Meltdown                                                                     
This exploit is specific to Intel processors and exploits speculative code
execution of the CPU hardware. This is an optimisation that the CPU can do
to improve performace where the execution pipeline prefetches instructions and
runs them, but does not retire (make the result of the execution available) the
result of the exectuion if that code path is not taken. The issue is that the
CPU cache might still have been updated by the instructions that where
executed (but whose path was not taken). This can be detected by using measuring
the time it takes to access a value, if it takes longer to access then the
value was in memory, but if it is fast then the data was in the CPU cache.

The idea here is that we create an array that acts as a side channel:
```
  0                                                                 4095
  +-----------------------------------------------------------------+
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  |-----------------------------------------------------------------|
  +-----------------------------------------------------------------+
255

1111 1111 = 8 bits = 1 byte = 255
``` 
So what we have here 256 entries which are 4096 in size (the same size as a
page). And notice 0-255 can be represented by `11111111` which is one byte.

Now, we first want to make sure the one of the values in our side channel are
in the cache. This can be done by using `_mm_clflush` for example.

Next, we want to read a byte of memory from the kernel address space which is
something that will cause a segment fault. But that is alright in our case and
expected to happen.
So after this step we have a byte value that was read from kernal memory but
we cannot access this value as it will never be exposed to us because that
data will never retired and made available, but it will have been added to the
CPU cache. 

The next part of our code will use the kernel byte value and multiply that with
the column size of our side channel, followed by accessing that value in or
side channel array. Now remember that this will segfault because we are
accessing protected memory so we need a fault handler to handle that and
continue executing our code.
The next step is to iterate over the array and read every element and measure
the time it takes to access that position. If one of the 0-255 row elements
takes a short amount of time that value was in the cache and if we take the
binary value of that entry, like say it was row element 116 that took a short
period of time to access, that would be `0111 0100` in binary and that would be
the value of the byte read from the kernel.

_wip_

```c
  uint8_t* side_channel = new uint8_t[256 * 4096];

  for (int i = 0; i < side_channel; i+=cache_line_size) {                          
    _mm_clflush(&side_channel[i]);                                                      
  }                                                                              


  uint8_t kernel_memory = *(uint8_t*)(kernel_address);
  uint64_t final_kernel_memory = kernel_memory * 4096;
  uint8_t unused = side_channel[final_kernel_memory];
```

allocate an array of a certain size, being a multiple of the cache lines size    
which is 64KB:                                                                   
```c                                                                             
int array[256 * 64];                                                             
```                                                                              
Next, we are going                                                               
```c                                                                             
  for (int i = 0; i < cache_size; i+=cache_line_size) {                          
    _mm_clflush(&array[i]);                                                      
  }                                                                              
```
