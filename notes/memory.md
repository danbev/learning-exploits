## Memory layout notes

### memory addressing
On a 64 bit system addresses are 64 bits, that means that 64 bits specified
using 64 bits:
```
                        ffffffffffffffff

 f    f     f    f     f    f     f    f    f    f    f    f    f    f    f    f
1111 1111  1111 1111  1111 1111  1111 1111 1111 1111 1111 1111 1111 1111 1111 1111
 2⁴   2⁴    2⁴   2⁴    2⁴   2⁴    2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   (2⁴)¹⁶ = 1.844674407e+19
 16   16    16   16    16   16    16   16   16   16   16   16   16   16   16   16   16¹⁶   = 1.844674407e+19
```
But only 64 - 16 = 48 bits are used for addressing.
```
                        fffffffffffffff

 f    f     f    f     f    f     f    f    f    f    f    f    f    f    f
1111 1111  1111 1111  1111 1111  1111 1111 1111 1111 1111 1111 1111 1111 1111
 2⁴   2⁴    2⁴   2⁴    2⁴   2⁴    2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   (2⁴)¹5 = 1.153921505e+18
 16   16    16   16    16   16    16   16   16   16   16   16   16   16   16   16¹⁵   = 1.153921505e+18
```


### memory layout
Notice that while the memory available in the system is
0xffffffffffffffff
0x7fffffffd160    

```                                                        
 0xffffffffffff     +----------------------------------+                                                 
 0xfffffffffffe     |__________________________________|
 0xfffffffffffd     |__________________________________|
 0xfffffffffffc     |__________________________________|
 0xfffffffffffb     |__________________________________|
 0xfffffffffffa     |__________________________________|
 0xfffffffffff9     |__________________________________|
 0xfffffffffff8     |__________________________________|
 0xfffffffffff7     |__________________________________|
 0xfffffffffff6     |__________________________________|
 0xfffffffffff5     |__________________________________|
 0xfffffffffff4     |__________________________________|
 0xfffffffffff3     |__________________________________|
 0xfffffffffff2     |__________________________________|
 0xfffffffffff1     |__________________________________|
 0xfffffffffff0     |__________________________________|
 0xffffffffffef     |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
 0x000000000012     |__________________________________|
 0x000000000011     |__________________________________|
 0x000000000010     |__________________________________|
 0x00000000000f     |__________________________________|
 0x00000000000e     |__________________________________|
 0x00000000000d     |__________________________________|
 0x00000000000c     |__________________________________|
 0x00000000000b     |__________________________________|
 0x00000000000a     |__________________________________|
 0x000000000009     |__________________________________|
 0x000000000008     |__________________________________|
 0x000000000007     |__________________________________|
 0x000000000006     |__________________________________|
 0x000000000005     |__________________________________|
 0x000000000004     |__________________________________|
 0x000000000003     |__________________________________|
 0x000000000002     |__________________________________|
 0x000000000001     |__________________________________|
 0x000000000000     |__________________________________|

```


The following the stack when entering main in [memory.c](./src/memory.c).
One thing to realise is that when we read memory in lldb we choose how to
see the contents of one or memory addresses. For example:
```console
(lldb) memory read -f x  -c 8 -s 1 $rsp
0x7fffffffd0f0: 0xe8 0xd1 0xff 0xff 0xff 0x7f 0x00 0x00
```
This will show a single memory address and its entire contents. If we specify
one more it will show the next memory address:
```console
(lldb) memory read -f x  -c 9 -s 1 $rsp
0x7fffffffd0f0: 0xe8 0xd1 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffd0f8: 0x00
```
So each memory address contains:
```console
(lldb) memory read -f x -c 1 -s 1 $rsp
0x7fffffffd0f0: 0x00007fffffffd1e8
```
So each memory address can hold ffffffffffffffff (64 bits, 8 bytes).
Now, when you use `memory read` you might see:
```console
(lldb) memory read -f x -c 3 -s 8 $rsp
0x7fffffffd0f0: 0x00007fffffffd1e8 0x0000000100000000
0x7fffffffd100: 0x0000000000401130
```
Which is actually showing the two items on the same line, which looks like they
have the same addess to me. But we can specify how many items to display per
line using `-l`:

```console
(lldb) memory read -f x -c 3 -s 8 $rsp -l 1
0x7fffffffd0f0: 0x00007fffffffd1e8
0x7fffffffd0f8: 0x0000000100000000
0x7fffffffd100: 0x0000000000401130
```
If we look at the addresses we can see hat we are looking at increments of 8.

The default in lldb is to display size of 4 bytes
```console
(lldb) memory read -f x '$rsp'
0x7fffffffd0f0: 0xffffd1e8 0x00007fff 0x00000000 0x00000001
0x7fffffffd100: 0x00401130 0x00000000 0xf7e031a3 0x00007fff
(lldb) memory read -f x -s 4 -c 8 '$rsp'
0x7fffffffd0f0: 0xffffd1e8 0x00007fff 0x00000000 0x00000001
0x7fffffffd100: 0x00401130 0x00000000 0xf7e031a3 0x00007fff

(lldb) memory read -f x -s 1 -c 8 '$rsp' -l 1
0x7fffffffd0f0: 0xe8
0x7fffffffd0f1: 0xd1
0x7fffffffd0f2: 0xff
0x7fffffffd0f3: 0xff
0x7fffffffd0f4: 0xff
0x7fffffffd0f5: 0x7f
0x7fffffffd0f6: 0x00
0x7fffffffd0f7: 0x00
```
So each address 0x7fffffffd0f0 is storing 0xe8 (0b11101000)
```
0xe8
14*16 + 8 = 232 
11101000  = 232
```
So the max value that can be stored in each address is 255, that is one byte
1111 1111.
Now, if we specify a size of 8 bytes, the this will also mean that the next
line will be +8:
```console
(lldb) memory read -f x -s 8 -c 2 '$rsp' -l 1
0x7fffffffd0f0: 0x00007fffffffd1e8
0x7fffffffd0f8: 0x0000000100000000
```
So we are able to address/point to a single byte and then the size will determine
how large the data to be read is.

```                                                        
 0x7fffffffd0f0     +----------------------------------+  <-- $rsp                                               
 0xfffffffffffe     |__________________________________|
 0xfffffffffffd     |__________________________________|
 0xfffffffffffc     |__________________________________|
 0xfffffffffffb     |__________________________________|
 0xfffffffffffa     |__________________________________|
 0xfffffffffff9     |__________________________________|
 0xfffffffffff8     |__________________________________|
 0xfffffffffff7     |__________________________________|
 0xfffffffffff6     |__________________________________|
 0xfffffffffff5     |__________________________________|
 0xfffffffffff4     |__________________________________|
 0xfffffffffff3     |__________________________________|
 0xfffffffffff2     |__________________________________|
 0xfffffffffff1     |__________________________________|
 0xfffffffffff0     |__________________________________|
 0xffffffffffef     |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
 0x000000000012     |__________________________________|
 0x000000000011     |__________________________________|
 0x000000000010     |__________________________________|
 0x00000000000f     |__________________________________|
 0x00000000000e     |__________________________________|
 0x00000000000d     |__________________________________|
 0x00000000000c     |__________________________________|
 0x00000000000b     |__________________________________|
 0x00000000000a     |__________________________________|
 0x000000000009     |__________________________________|
 0x000000000008     |__________________________________|
 0x000000000007     |__________________________________|
 0x000000000006     |__________________________________|
 0x000000000005     |__________________________________|
 0x000000000004     |__________________________________|
 0x000000000003     |__________________________________|
 0x000000000002     |__________________________________|
 0x000000000001     |__________________________________|
 0x000000000000     |__________________________________|



0x000000000000                                                  0xffffffffffff      
              +-------------------------------------------------+
              | text | data| heap->               <-stack | cmd |
              +-------------------------------------------------+


                                                      (arg1 = rdi)
                                                      (arg2 = rsi)
                                                      (arg3 = rdx)
                                                      (arg4 = rcx)
                                                      (arg5 = r8)
                                                      (arg6 = r9)
              +-------------------------------------------------+
              |                          | rbp | rip | arg7 |   |
              +-------------------------------------------------+
```

Looking a we should be comfortable reading out information from the stack.
For example is we inspect the stack and we are only interested in values
that have been pushed onto the stack which means that :
```console
(lldb) file overwrite
(lldb) br s -n main --skip-prologue false
(lldb) r
(lldb) memory read -f x -s 8 -l 1 '$rbp'
0x7fffffffd0f0: 0x0000000000401130    <- old rbp
0x7fffffffd0f8: 0x00007ffff7e031a3    <- rip for caller
0x7fffffffd100: 0x0000000000000000
0x7fffffffd108: 0x00007fffffffd1d8
0x7fffffffd110: 0x0000000400040000
0x7fffffffd118: 0x0000000000401110
0x7fffffffd120: 0x0000000000000000
0x7fffffffd128: 0x7c5dade37cd3ddc6
```
+------------------+------------------+------------------+------------------+
|0x0000000000401130|0x00007ffff7e031a3|0x0000000000000000|0x00007fffffffd1d8|
+------------------+------------------+------------------+------------------+
↑                  ↑                  ↑                  ↑
0x7fffffffd0f0     0x7fffffffd0f8     0x7fffffffd100     0x7fffffffd108 
old rbp                  rip          caller local var   caller local var
```
Notice that the addresses are larger to the right/down and this is a good way
to visualize the stack, visualize that they first one stays in place and the
lower ones move up to the right next to it.
We can also list all the values on a single line:
```console
(lldb) memory read -f x -c 4 -s 8 $rsp -l 4
0x7fffffffd0e0: 0x104000007fffffffd1e8 0xffffd1e0000000010040 0x00000000000000007fff
```

Another things to also keep in mind is that when addressing the smallest unit
we can address is a byte 1111 1111, 0xFF. In the debugger we can display data
from the stack using rsp and a count we are looking at the values to the right:
```console
(lldb) memory read -l 1 -f x -s 1 -c 8 $rsp
0x7fffffffd1e0: 0x01
0x7fffffffd1e1: 0x00
0x7fffffffd1e2: 0x00
0x7fffffffd1e3: 0x00
0x7fffffffd1e4: 0x00
0x7fffffffd1e5: 0x00
0x7fffffffd1e6: 0x00
0x7fffffffd1e7: 0x00
(lldb) memory read -l 8 -f x -s 1 -c 8 $rsp
0x7fffffffd1e0: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00
```
Now normally looking at values below the rsp might not be useful that ofter
but looking at values below rbp is and the same applies to it. So to display
the contents below rsp we can use:
```console
(lldb) memory read -l 1 -f x -s 1 -c 9 '$rsp-8'
0x7fffffffd1d8: 0x00
0x7fffffffd1d9: 0x00
0x7fffffffd1da: 0x00
0x7fffffffd1db: 0x00
0x7fffffffd1dc: 0x00
0x7fffffffd1dd: 0x00
0x7fffffffd1de: 0x00
0x7fffffffd1df: 0x00
0x7fffffffd1e0: 0x01
```
Notice that in this case we are starting form the left most value on the stack
and up and including rsp:
```console
(lldb) memory read -l 9 -f x -s 1 -c 9 '$rsp-8'
0x7fffffffd1d8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01
```

Endianness is not an issue for these smallest units (bytes) but do come into
play when multiple bytes make up a value. So way we have 256 that we want to
store on the stack which will not fit into a single byte. Now, if we try to
push values onto the stack we might think that these will take up one byte if
that is what we are pushing, but that is not the case. The unit that push handles
is the size of 64-bits, 8 bytes on a 64-bit processor.
```assembly
  push $255
  push $256
```
```console
(lldb) memory read -l 8 -f x -s 1 -c 16 '$rsp'
0x7fffffffd1d0: 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffd1d8: 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00
```

Also Notice that the addresss on the stack all start with 7ffff which is higher
up in the processes memory space. And addresses like 0x0000000000401130 are
closer to the bottom of the processes memory space, and would therefore be part
of heap/data/text sections. And the ones that don't look like that att all could
be values. This is useful when reading/skimming code and trying to understand
what is going on.

In most cases on x86 where most parameters are passed in registers (the first
6 in rdi, rsi, rdx, rcx, r8, and r9) the stack will mostly only contain the
value of `rip` and `rbp`.

We can also list all the values on a single line:
```console
(lldb) memory read -f x -c 10 -s 10 $rsp -l 10
0x7fffffffd0e0: 0x104000007fffffffd1e8 0xffffd1e0000000010040 0x00000000000000007fff 0x00000000004011e00000 0x000000007ffff7e031a3 0xffffd1e8000000000000 0x00010004000000007fff 0x00000000004011260000 0xcb520000000000000000 0x00401040ee2f6216c45b
```
This might help as you can then visualize that the entries below are infact
to the right hence higher up in memory.

Now, seeing 0x0000000000401130 is actually the rbp for the calling function, 
remember that we are in main which was called lib_c_start and if we do back up
we can verify this:
```console
frame #1: 0x00007ffff7e031a3 libc.so.6`.annobin_libc_start.c + 243
libc.so.6`.annobin_libc_start.c:
->  0x7ffff7e031a3 <+243>: mov    edi, eax
    0x7ffff7e031a5 <+245>: call   0x7ffff7e1b020            ; __GI_exit
    0x7ffff7e031aa <+250>: mov    rax, qword ptr [rsp + 0x8]
    0x7ffff7e031af <+255>: lea    rdi, [rip + 0x1658db]
```
And notice that the value pointed to is the value of eip which will be used by
`ret` to cause the program to continue execution there once this function is
finished.


### read a pointer-to-pointer
```console
(lldb) memory read -f s -c 1  '*(int**)(0x00007fffffffd1d8)'
0x7fffffffd5b1: "/home/danielbevenius/work/security/learning-exploits/memory"
```

### sizes
dword is 4 bytes, 32 bits. Used for ints.
qword is 8 bytes, 64 bits. Used for pointers.

```console
(lldb) dis -b -p
formatstring`main:
->  0x40114d <+1>:  48 89 e5     mov    rbp, rsp
    0x401150 <+4>:  48 83 ec 20  sub    rsp, 0x20
    0x401154 <+8>:  89 7d ec     mov    dword ptr [rbp - 0x14], edi
    0x401157 <+11>: 48 89 75 e0  mov    qword ptr [rbp - 0x20], rsi
```
Notice the copying of argc which is in rdi onto the stack. This saying that the
contents of the address rbp-0x14 and  dereference it as a dword, 4 bytes and
set that to the value of rdi. This is like casting in C.


### Finding libc function addresses
```console
(lldb) expr printf
(int (*)(const char *__restrict, ...)) $11 = 0x00007ffff7e33cb0 (libc.so.6`.annobin_printf.c)

(lldb) expr (int(*)()) exit
(int (*)()) $12 = 0x00007ffff7e1b020 (libc.so.6`__GI_exit)

(lldb) expr (int(*)(const char*)) system
(int (*)(const char *)) $10 = 0x00007ffff7e259f0 (libc.so.6`system)

```

### Instructions in memory
So when writing shellcode we need to take the instructions and place them in
memory. For this we need to put the bytes in little endian. I was a little
confused about that as inspecting the instructions in lldb shows them in big
endian (using the --binary option):
```console
(lldb) disassemble -b
carry`_start:
    0x401000 <+0>:  48 c7 c0 0a 00 00 00  mov    rax, 0xa
->  0x401007 <+7>:  48 c7 c6 09 00 00 00  mov    rsi, 0x9
    0x40100e <+14>: 48 39 c6              cmp    rsi, rax
```
But if we actually read the memory we can see they are infact in little endian:
```console
(lldb) memory read -f x 0x401000 -c 1 -s 4
0x00401000: 0x0ac0c748
```

### Core dumps
```console
$ ls /var/lib/systemd/coredump/
...
-rw-r-----+ 1 root root     27806 Mar 10 13:06 core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000.lz4
```
```console
$ sudo unlz4  /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000.lz4
[sudo] password for danielbevenius: 
Decoding file /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000 
/var/lib/systemd/cor : decoded 393216 bytes
```

```console
$ sudo file /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000
/var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './overwrite', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: './overwrite', platform: 'x86_64'
$ sudo chmow danielbevevnius /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000
```

Load the executable and the core dump in lldb:
```console
$ lldb overwrite -c /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000
(lldb) target create "overwrite" --core "/var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000"
Core file '/var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000' (x86_64) was loaded.
```
Now you can see where the the core dumpe was generated and inspect the state of
the program.

