## Memory layout notes

### memory addressing
On a 64 bit system addresses are 64 bits, that means that 64 bits specified
using 64 bits:
```
                        ffffffffffffffff

 f    f     f    f     f    f     f    f    f    f    f    f    f    f    f    f
1111 1111  1111 1111  1111 1111  1111 1111 1111 1111 1111 1111 1111 1111 1111 1111
 2⁴   2⁴    2⁴   2⁴    2⁴   2⁴    2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   (2⁴)¹⁶ = 1.844674407e+19
 16   16    16   16    16   16    16   16   16   16   16   16   16   16   16   16   16¹⁶   = 1.844674407e+19
```
But only 64 - 16 = 48 bits are used for addressing.
```
                        fffffffffffffff

 f    f     f    f     f    f     f    f    f    f    f    f    f    f    f
1111 1111  1111 1111  1111 1111  1111 1111 1111 1111 1111 1111 1111 1111 1111
 2⁴   2⁴    2⁴   2⁴    2⁴   2⁴    2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   2⁴   (2⁴)¹5 = 1.153921505e+18
 16   16    16   16    16   16    16   16   16   16   16   16   16   16   16   16¹⁵   = 1.153921505e+18
```


### memory layout
Notice that while the memory available in the system is
0xffffffffffffffff
0x7fffffffd160    

```                                                        
 0xffffffffffff     +----------------------------------+                                                 
 0xfffffffffffe     |__________________________________|
 0xfffffffffffd     |__________________________________|
 0xfffffffffffc     |__________________________________|
 0xfffffffffffb     |__________________________________|
 0xfffffffffffa     |__________________________________|
 0xfffffffffff9     |__________________________________|
 0xfffffffffff8     |__________________________________|
 0xfffffffffff7     |__________________________________|
 0xfffffffffff6     |__________________________________|
 0xfffffffffff5     |__________________________________|
 0xfffffffffff4     |__________________________________|
 0xfffffffffff3     |__________________________________|
 0xfffffffffff2     |__________________________________|
 0xfffffffffff1     |__________________________________|
 0xfffffffffff0     |__________________________________|
 0xffffffffffef     |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
 0x000000000012     |__________________________________|
 0x000000000011     |__________________________________|
 0x000000000010     |__________________________________|
 0x00000000000f     |__________________________________|
 0x00000000000e     |__________________________________|
 0x00000000000d     |__________________________________|
 0x00000000000c     |__________________________________|
 0x00000000000b     |__________________________________|
 0x00000000000a     |__________________________________|
 0x000000000009     |__________________________________|
 0x000000000008     |__________________________________|
 0x000000000007     |__________________________________|
 0x000000000006     |__________________________________|
 0x000000000005     |__________________________________|
 0x000000000004     |__________________________________|
 0x000000000003     |__________________________________|
 0x000000000002     |__________________________________|
 0x000000000001     |__________________________________|
 0x000000000000     |__________________________________|

```


The following the stack when entering main in [memory.c](./src/memory.c).
One thing to realise is that when we read memory in lldb we choose how to
see the contents of one or memory addresses. For example:
```console
(lldb) memory read -f x  -c 8 -s 1 $rsp
0x7fffffffd0f0: 0xe8 0xd1 0xff 0xff 0xff 0x7f 0x00 0x00
```
This will show a single memory address and its entire contents. If we specify
one more it will show the next memory address:
```console
(lldb) memory read -f x  -c 9 -s 1 $rsp
0x7fffffffd0f0: 0xe8 0xd1 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffd0f8: 0x00
```
So each memory address contains:
```console
(lldb) memory read -f x -c 1 -s 1 $rsp
0x7fffffffd0f0: 0x00007fffffffd1e8
```
So each memory address can hold ffffffffffffffff (64 bits, 8 bytes).
Now, when you use `memory read` you might see:
```console
(lldb) memory read -f x -c 3 -s 8 $rsp
0x7fffffffd0f0: 0x00007fffffffd1e8 0x0000000100000000
0x7fffffffd100: 0x0000000000401130
```
Which is actually showing the two items on the same line, which looks like they
have the same addess to me. But we can specify how many items to display per
line using `-l`:

```console
(lldb) memory read -f x -c 3 -s 8 $rsp -l 1
0x7fffffffd0f0: 0x00007fffffffd1e8
0x7fffffffd0f8: 0x0000000100000000
0x7fffffffd100: 0x0000000000401130
```
If we look at the addresses we can see hat we are looking at increments of 8.

The default in lldb is to display size of 4 bytes
```console
(lldb) memory read -f x '$rsp'
0x7fffffffd0f0: 0xffffd1e8 0x00007fff 0x00000000 0x00000001
0x7fffffffd100: 0x00401130 0x00000000 0xf7e031a3 0x00007fff
(lldb) memory read -f x -s 4 -c 8 '$rsp'
0x7fffffffd0f0: 0xffffd1e8 0x00007fff 0x00000000 0x00000001
0x7fffffffd100: 0x00401130 0x00000000 0xf7e031a3 0x00007fff

(lldb) memory read -f x -s 1 -c 8 '$rsp' -l 1
0x7fffffffd0f0: 0xe8
0x7fffffffd0f1: 0xd1
0x7fffffffd0f2: 0xff
0x7fffffffd0f3: 0xff
0x7fffffffd0f4: 0xff
0x7fffffffd0f5: 0x7f
0x7fffffffd0f6: 0x00
0x7fffffffd0f7: 0x00
```
So each address 0x7fffffffd0f0 is storing 0xe8 (0b11101000)
```
0xe8
14*16 + 8 = 232 
11101000  = 232
```
So the max value that can be stored in each address is 255, that is one byte
1111 1111.
Now, if we specify a size of 8 bytes, the this will also mean that the next
line will be +8:
```console
(lldb) memory read -f x -s 8 -c 2 '$rsp' -l 1
0x7fffffffd0f0: 0x00007fffffffd1e8
0x7fffffffd0f8: 0x0000000100000000
```
So we are able to address/point to a single byte and then the size will determine
how large the data to be read is.

```                                                        
 0x7fffffffd0f0     +----------------------------------+  <-- $rsp                                               
 0xfffffffffffe     |__________________________________|
 0xfffffffffffd     |__________________________________|
 0xfffffffffffc     |__________________________________|
 0xfffffffffffb     |__________________________________|
 0xfffffffffffa     |__________________________________|
 0xfffffffffff9     |__________________________________|
 0xfffffffffff8     |__________________________________|
 0xfffffffffff7     |__________________________________|
 0xfffffffffff6     |__________________________________|
 0xfffffffffff5     |__________________________________|
 0xfffffffffff4     |__________________________________|
 0xfffffffffff3     |__________________________________|
 0xfffffffffff2     |__________________________________|
 0xfffffffffff1     |__________________________________|
 0xfffffffffff0     |__________________________________|
 0xffffffffffef     |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
                    |__________________________________|
 0x000000000012     |__________________________________|
 0x000000000011     |__________________________________|
 0x000000000010     |__________________________________|
 0x00000000000f     |__________________________________|
 0x00000000000e     |__________________________________|
 0x00000000000d     |__________________________________|
 0x00000000000c     |__________________________________|
 0x00000000000b     |__________________________________|
 0x00000000000a     |__________________________________|
 0x000000000009     |__________________________________|
 0x000000000008     |__________________________________|
 0x000000000007     |__________________________________|
 0x000000000006     |__________________________________|
 0x000000000005     |__________________________________|
 0x000000000004     |__________________________________|
 0x000000000003     |__________________________________|
 0x000000000002     |__________________________________|
 0x000000000001     |__________________________________|
 0x000000000000     |__________________________________|



0x000000000000                                                  0xffffffffffff      
              +-------------------------------------------------+
              | text | data| heap->               <-stack | cmd |
              +-------------------------------------------------+


                                                      (arg1 = rdi)
                                                      (arg2 = rsi)
                                                      (arg3 = rdx)
                                                      (arg4 = rcx)
                                                      (arg5 = r8)
                                                      (arg6 = r9)
              +-------------------------------------------------+
              |                          | rbp | rip | arg7 |   |
              +-------------------------------------------------+
```

Looking a we should be comfortable reading out information from the stack.
For example is we inspect the stack and we are only interested in values
that have been pushed onto the stack which means that :
```console
(lldb) file overwrite
(lldb) br s -n main --skip-prologue false
(lldb) r
(lldb) memory read -f x -s 8 -l 1 '$rbp'
0x7fffffffd0f0: 0x0000000000401130    <- old rbp
0x7fffffffd0f8: 0x00007ffff7e031a3    <- rip for caller
0x7fffffffd100: 0x0000000000000000
0x7fffffffd108: 0x00007fffffffd1d8
0x7fffffffd110: 0x0000000400040000
0x7fffffffd118: 0x0000000000401110
0x7fffffffd120: 0x0000000000000000
0x7fffffffd128: 0x7c5dade37cd3ddc6
```
+------------------+------------------+------------------+------------------+
|0x0000000000401130|0x00007ffff7e031a3|0x0000000000000000|0x00007fffffffd1d8|
+------------------+------------------+------------------+------------------+
↑                  ↑                  ↑                  ↑
0x7fffffffd0f0     0x7fffffffd0f8     0x7fffffffd100     0x7fffffffd108 
old rbp                  rip          caller local var   caller local var
```
Notice that the addresses are larger to the right/down and this is a good way
to visualize the stack, visualize that they first one stays in place and the
lower ones move up to the right next to it.
We can also list all the values on a single line:
```console
(lldb) memory read -f x -c 4 -s 8 $rsp -l 4
0x7fffffffd0e0: 0x104000007fffffffd1e8 0xffffd1e0000000010040 0x00000000000000007fff
```

Another things to also keep in mind is that when addressing the smallest unit
we can address is a byte 1111 1111, 0xFF. In the debugger we can display data
from the stack using rsp and a count we are looking at the values to the right:
```console
(lldb) memory read -l 1 -f x -s 1 -c 8 $rsp
0x7fffffffd1e0: 0x01
0x7fffffffd1e1: 0x00
0x7fffffffd1e2: 0x00
0x7fffffffd1e3: 0x00
0x7fffffffd1e4: 0x00
0x7fffffffd1e5: 0x00
0x7fffffffd1e6: 0x00
0x7fffffffd1e7: 0x00
(lldb) memory read -l 8 -f x -s 1 -c 8 $rsp
0x7fffffffd1e0: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00
```
Now normally looking at values below the rsp might not be useful that ofter
but looking at values below rbp is and the same applies to it. So to display
the contents below rsp we can use:
```console
(lldb) memory read -l 1 -f x -s 1 -c 9 '$rsp-8'
0x7fffffffd1d8: 0x00
0x7fffffffd1d9: 0x00
0x7fffffffd1da: 0x00
0x7fffffffd1db: 0x00
0x7fffffffd1dc: 0x00
0x7fffffffd1dd: 0x00
0x7fffffffd1de: 0x00
0x7fffffffd1df: 0x00
0x7fffffffd1e0: 0x01
```
Notice that in this case we are starting form the left most value on the stack
and up and including rsp:
```console
(lldb) memory read -l 9 -f x -s 1 -c 9 '$rsp-8'
0x7fffffffd1d8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01
```

Endianness is not an issue for these smallest units (bytes) but do come into
play when multiple bytes make up a value. So way we have 256 that we want to
store on the stack which will not fit into a single byte. Now, if we try to
push values onto the stack we might think that these will take up one byte if
that is what we are pushing, but that is not the case. The unit that push handles
is the size of 64-bits, 8 bytes on a 64-bit processor.
```assembly
  push $255
  push $256
```
```console
(lldb) memory read -l 8 -f x -s 1 -c 16 '$rsp'
0x7fffffffd1d0: 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00
0x7fffffffd1d8: 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00
```

Also Notice that the addresss on the stack all start with 7ffff which is higher
up in the processes memory space. And addresses like 0x0000000000401130 are
closer to the bottom of the processes memory space, and would therefore be part
of heap/data/text sections. And the ones that don't look like that att all could
be values. This is useful when reading/skimming code and trying to understand
what is going on.

In most cases on x86 where most parameters are passed in registers (the first
6 in rdi, rsi, rdx, rcx, r8, and r9) the stack will mostly only contain the
value of `rip` and `rbp`.

We can also list all the values on a single line:
```console
(lldb) memory read -f x -c 10 -s 10 $rsp -l 10
0x7fffffffd0e0: 0x104000007fffffffd1e8 0xffffd1e0000000010040 0x00000000000000007fff 0x00000000004011e00000 0x000000007ffff7e031a3 0xffffd1e8000000000000 0x00010004000000007fff 0x00000000004011260000 0xcb520000000000000000 0x00401040ee2f6216c45b
```
This might help as you can then visualize that the entries below are infact
to the right hence higher up in memory.

Now, seeing 0x0000000000401130 is actually the rbp for the calling function, 
remember that we are in main which was called lib_c_start and if we do back up
we can verify this:
```console
frame #1: 0x00007ffff7e031a3 libc.so.6`.annobin_libc_start.c + 243
libc.so.6`.annobin_libc_start.c:
->  0x7ffff7e031a3 <+243>: mov    edi, eax
    0x7ffff7e031a5 <+245>: call   0x7ffff7e1b020            ; __GI_exit
    0x7ffff7e031aa <+250>: mov    rax, qword ptr [rsp + 0x8]
    0x7ffff7e031af <+255>: lea    rdi, [rip + 0x1658db]
```
And notice that the value pointed to is the value of eip which will be used by
`ret` to cause the program to continue execution there once this function is
finished.


### read a pointer-to-pointer
```console
(lldb) memory read -f s -c 1  '*(int**)(0x00007fffffffd1d8)'
0x7fffffffd5b1: "/home/danielbevenius/work/security/learning-exploits/memory"
```

### sizes
dword is 4 bytes, 32 bits. Used for ints.
qword is 8 bytes, 64 bits. Used for pointers.

```console
(lldb) dis -b -p
formatstring`main:
->  0x40114d <+1>:  48 89 e5     mov    rbp, rsp
    0x401150 <+4>:  48 83 ec 20  sub    rsp, 0x20
    0x401154 <+8>:  89 7d ec     mov    dword ptr [rbp - 0x14], edi
    0x401157 <+11>: 48 89 75 e0  mov    qword ptr [rbp - 0x20], rsi
```
Notice the copying of argc which is in rdi onto the stack. This saying that the
contents of the address rbp-0x14 and  dereference it as a dword, 4 bytes and
set that to the value of rdi. This is like casting in C.


### Finding libc function addresses
```console
(lldb) expr printf
(int (*)(const char *__restrict, ...)) $11 = 0x00007ffff7e33cb0 (libc.so.6`.annobin_printf.c)

(lldb) expr (int(*)()) exit
(int (*)()) $12 = 0x00007ffff7e1b020 (libc.so.6`__GI_exit)

(lldb) expr (int(*)(const char*)) system
(int (*)(const char *)) $10 = 0x00007ffff7e259f0 (libc.so.6`system)

```

### Instructions in memory
So when writing shellcode we need to take the instructions and place them in
memory. For this we need to put the bytes in little endian. I was a little
confused about that as inspecting the instructions in lldb shows them in big
endian (using the --binary option):
```console
(lldb) disassemble -b
carry`_start:
    0x401000 <+0>:  48 c7 c0 0a 00 00 00  mov    rax, 0xa
->  0x401007 <+7>:  48 c7 c6 09 00 00 00  mov    rsi, 0x9
    0x40100e <+14>: 48 39 c6              cmp    rsi, rax
```
But if we actually read the memory we can see they are infact in little endian:
```console
(lldb) memory read -f x 0x401000 -c 1 -s 4
0x00401000: 0x0ac0c748
```

### Core dumps
```console
$ ls /var/lib/systemd/coredump/
...
-rw-r-----+ 1 root root     27806 Mar 10 13:06 core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000.lz4
```
```console
$ sudo unlz4  /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000.lz4
[sudo] password for danielbevenius: 
Decoding file /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000 
/var/lib/systemd/cor : decoded 393216 bytes
```

```console
$ sudo file /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000
/var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './overwrite', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: './overwrite', platform: 'x86_64'
$ sudo chmow danielbevevnius /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000
```

Load the executable and the core dump in lldb:
```console
$ lldb overwrite -c /var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000
(lldb) target create "overwrite" --core "/var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000"
Core file '/var/lib/systemd/coredump/core.overwrite.1000.5ade29a3e725401da3b266d0cf9266ff.2736377.1615377960000000' (x86_64) was loaded.
```
Now you can see where the the core dumpe was generated and inspect the state of
the program.

### Memory layout
To get a better understanding about how memory is layed out we can inspect the
mmap for a process.
```console
$ lldb overwrite
(lldb) br s -n main
Breakpoint 1: where = overwrite`main + 15 at overwrite.c:9:8, address = 0x0000000000401166
(lldb) r
```
Now we can put this progess in the back, and take note of the process id in lldb
first which in my case is `2781456`.

```console
$ cat /proc/2781456/maps 
Address                  perm  offset   dev   inode     path name
00400000-00403000         r-xp 00000000 fd:02 24423971  /home/danielbevenius/work/security/learning-exploits/overwrite
00403000-00404000         r-xp 00002000 fd:02 24423971  /home/danielbevenius/work/security/learning-exploits/overwrite
00404000-00405000         rwxp 00003000 fd:02 24423971  /home/danielbevenius/work/security/learning-exploits/overwrite
7ffff7ddc000-7ffff7f9a000 r-xp 00000000 fd:00 1714961   /usr/lib64/libc-2.30.so
7ffff7f9a000-7ffff7f9b000 ---p 001be000 fd:00 1714961   /usr/lib64/libc-2.30.so
7ffff7f9b000-7ffff7f9e000 r-xp 001be000 fd:00 1714961   /usr/lib64/libc-2.30.so
7ffff7f9e000-7ffff7fa1000 rwxp 001c1000 fd:00 1714961   /usr/lib64/libc-2.30.so
7ffff7fa1000-7ffff7fa7000 rwxp 00000000 00:00 0 
7ffff7fcb000-7ffff7fcf000 r--p 00000000 00:00 0         [vvar]
7ffff7fcf000-7ffff7fd1000 r-xp 00000000 00:00 0         [vdso]
7ffff7fd1000-7ffff7ffb000 r-xp 00000000 fd:00 1714954   /usr/lib64/ld-2.30.so
7ffff7ffc000-7ffff7ffd000 r-xp 0002a000 fd:00 1714954   /usr/lib64/ld-2.30.so
7ffff7ffd000-7ffff7ffe000 rwxp 0002b000 fd:00 1714954   /usr/lib64/ld-2.30.so
7ffff7ffe000-7ffff7fff000 rwxp 00000000 00:00 0 
7ffffffdd000-7ffffffff000 rwxp 00000000 00:00 0         [stack]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
```
Now in the first column we have the memory regions (start and end addresses).
Next are the permissions which can be set, r=read, w=write, x=execute, s=shared,
p=private (copy on write).
The offset is the offset in the file. 

inode:
```console
$ ls -i overwrite
24423971 overwrite
```

So we can see that the first address range in from our executable (not the source
file remember that) and this region is readable and executable but not writable.
That could be the text section as it should not be writable.
`man proc` for details about /proc.

Now, the above is saying that the system has mapped data in our executable from
the offset 0000000 to 00002000 (hex) to the addresses 00400000-0040300.
in hex). So this is 3000 something bits or bytes?
```console
$ xxd overwrite
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0200 3e00 0100 0000 6010 4000 0000 0000  ..>.....`.@.....
00000020: 4000 0000 0000 0000 1058 0000 0000 0000  @........X......

(lldb) memory read -a 0x00400000 -c 500
0x00400000: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............
0x00400010: 02 00 3e 00 01 00 00 00 60 10 40 00 00 00 00 00  ..>.....`.@.....
0x00400020: 40 00 00 00 00 00 00 00 10 58 00 00 00 00 00 00  @........X......
```
And the next region starts at offset 2000 (hex):
```console
00002000: 0100 0200 0000 0000 0000 0000 0000 0000  ................
00002010: 736f 6d65 7468 696e 6720 7761 7320 6361  something was ca
00002020: 6c6c 6564 2121 0048 656c 6c6f 2c20 656e  lled!!.Hello, en
00002030: 7465 7220 796f 7572 206e 616d 653a 0000  ter your name:..
00002040: 4141 4141 4141 4141 4242 4242 4242 4242  AAAAAAAABBBBBBBB

(lldb) memory read -a 0x00403000 -c 500
0x00403000: 01 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x00403010: 73 6f 6d 65 74 68 69 6e 67 20 77 61 73 20 63 61  something was ca
0x00403020: 6c 6c 65 64 21 21 00 48 65 6c 6c 6f 2c 20 65 6e  lled!!.Hello, en
0x00403030: 74 65 72 20 79 6f 75 72 20 6e 61 6d 65 3a 00 00  ter your name:..
0x00403040: 41 41 41 41 41 41 41 41 42 42 42 42 42 42 42 42  AAAAAAAABBBBBBBB
```
And the final section from our executable is at offset 3000 and notice that this
region is readable and writable (and in our case executable as we've enabled
an executable stack):
```console
$ xxd overwrite
00003000: 203e 4000 0000 0000 0000 0000 0000 0000   >@.............
00003010: 0000 0000 0000 0000 3610 4000 0000 0000  ........6.@.....
00003020: 4610 4000 0000 0000 5610 4000 0000 0000  F.@.....V.@.....
00003030: 0000 0000 4743 433a 2028 474e 5529 2039  ....GCC: (GNU) 9
00003040: 2e33 2e31 2032 3032 3030 3430 3820 2852  .3.1 20200408 (R
00003050: 6564 2048 6174 2039 2e33 2e31 2d32 2900  ed Hat 9.3.1-2).
00003060: 0a00 0000 1000 0000 0001 0000 4741 2401  ............GA$.
00003070: 3368 3837 3800 0000 6010 4000 0000 0000  3h878...`.@.....
00003080: 6010 4000 0000 0000 1700 0000 0000 0000  `.@.............
00003090: 0001 0000 4741 2405 6763 6320 392e 332e  ....GA$.gcc 9.3.
000030a0: 3120 3230 3230 3034 3038 0000 0a00 0000  1 20200408......

(lldb) memory read -a 0x00404000 -c 500
0x00404000: 20 3e 40 00 00 00 00 00 50 e1 ff f7 ff 7f 00 00   >@.....P.......
0x00404010: 10 87 fe f7 ff 7f 00 00 36 10 40 00 00 00 00 00  ........6.@.....
0x00404020: 46 10 40 00 00 00 00 00 56 10 40 00 00 00 00 00  F.@.....V.@.....
0x00404030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
```
Notice how the first bytes match in this case but the memory at runtime differs
and contains less data.

In lldb we can use `memory region` to find out which region a address belongs
to:
```console
(lldb) memory region main
[0x0000000000400000-0x0000000000403000) r-x /home/danielbevenius/work/security/learning-exploits/overwrite PT_LOAD[1]
(lldb) memory region something
[0x0000000000400000-0x0000000000403000) r-x /home/danielbevenius/work/security/learning-exploits/overwrite PT_LOAD[1]
(lldb) memory region &buf
[0x00007ffffffdd000-0x00007ffffffff000) rwx [stack]
```

### lldb memory find
```console
(lldb) me fi -s "bajja" main main+1000
data found at location: 0x401168
0x00401168: 62 61 6a 6a 61 00 00 00 48 89 45 f0 bf 27 20 40  bajja...H.E..' @
0x00401178: 00 e8 c2 fe ff ff 48 c7 45 f8 40 20 40 00 48 8b  ......H.E.@ @.H.
```
